%rng(100)

delta_T = 0.1;
L = 0.5;
x0 = [10; 0; pi/2; -60; 0; -pi/2];
u0 = [2; -pi/18; 12; pi/25];

given = load('cooplocalization_finalproj_KFdata.mat');
Qtrue = given.Qtrue;
Rtrue = given.Rtrue;
yreal = given.ydata;
tvec = given.tvec;
measLabels = given.measLabels;

alpha_sig = 0.05;
num_sims = 50;

num_states = length(Qtrue);  % n
num_measurements = length(Rtrue);  % p

dx_hat_plus_0 = [0; 1; 0; 0; 0; 0.1];
%{
P_plus_0 = [10 0 0 0 0 0; ...
			0 10 0 0 0 0; ...
			0 0 0.0001 0 0 0; ...
			0 0 0 0.50 0 0; ...
			0 0 0 0 0.50 0; ...
			0 0 0 0 0 0.0005];  % make smaller

Qkf = [10*Qtrue(1,1) 0          0          0          0          0; ...
	   0          10*Qtrue(2,2) 0          0          0          0; ...
	   0          0          50*Qtrue(3,3) 0          0          0; ...
	   0          0          0          10*Qtrue(4,4) 0          0; ...
	   0          0          0          0          10*Qtrue(5,5) 0; ...
	   0          0          0          0          0          50*Qtrue(6,6)];
   %}

P_plus_0 = [5 0 0 5 0 0; ...
			0 5 0 0 5 0; ...
			0 0 0.02 0 0 0; ...
			5 0 0 5 0 0; ...
			0 5 0 0 5 0; ...
			0 0 0 0 0 0.05];  % make smaller
        %which states uncertain? what expc vary tog etc

Qkf = 100000/2.*[Qtrue(1,1) 0          0          0          0          0; ...
	   0          Qtrue(2,2) 0          0          0          0; ...
	   0          0          0.00001*Qtrue(3,3) 0          0          0; ...
	   0          0          0          Qtrue(4,4) 0          0; ...
	   0          0          0          0          Qtrue(5,5) 0; ...
	   0          0          0          0          0          0.00001*Qtrue(6,6)];
%{
P_plus_0=eye(6,6);
Qkf=Qtrue;
P_plus_0 = [5 0 0 5 0 0; ...
			0 5 0 0 5 0; ...
			0 0 0.02 0 0 0; ...
			5 0 0 5 0 0; ...
			0 5 0 0 5 0; ...
			0 0 0 0 0 0.05]; 
Qkf = 1.*[Qtrue(1,1) 0          0          0          0          0; ...
	   0          Qtrue(2,2) 0          0          0          0; ...
	   0          0          1*Qtrue(3,3) 0          0          0; ...
	   0          0          0          Qtrue(4,4) 0          0; ...
	   0          0          0          0          Qtrue(5,5) 0; ...
	   0          0          0          0          0          1*Qtrue(6,6)];
Rkf = Rtrue;
Qkf=  1000.*[Qtrue(1,1) 0          0          0          0          0; ...
	   0          Qtrue(2,2) 0          0          0          0; ...
	   0          0          Qtrue(3,3) 0          0          0; ...
	   0          0          0          Qtrue(4,4) 0          0; ...
	   0          0          0          0          Qtrue(5,5) 0; ...
	   0          0          0          0          0          Qtrue(6,6)];
   P_plus_0=1*[1 0 0 0 0 0; ...
			0 1 0 0 0 0; ...
			0 0 0.01 0 0 0; ...
			0 0 0 1 0 0; ...
			0 0 0 0 1 0; ...
			0 0 0 0 0 0.01];
       
   P_plus_0=2*[1 0 0 0 0 0; ...
			0 1 0 0 0 0; ...
			0 0 0.01 0 0 0; ...
			0 0 0 1 0 0; ...
			0 0 0 0 1 0; ...
			0 0 0 0 0 0.01];
        
        
%}
       
       P_plus_0 = [5 0 0 5 0 0; ...
     0 5 0 0 5 0; ...
	 0 0 0.02 0 0 0; ...
	 5 0 0 5 0 0; ...
	 0 5 0 0 5 0; ...
	 0 0 0 0 0 0.05];
       
       Qkf = [50000*Qtrue(1,1) 0          0          0          0          0; ...
	   0          50000*Qtrue(2,2) 0          0          0          0; ...
	   0          0          5*Qtrue(3,3) 0          0          0; ...
	   0          0          0          50000*Qtrue(4,4) 0          0; ...
	   0          0          0          0          50000*Qtrue(5,5) 0; ...
	   0          0          0          0          0          5*Qtrue(6,6)];
[xnom, ynom] = get_nominal_traj(x0, tvec, u0, L);

dx_hat_plus_prev = dx_hat_plus_0;
P_plus_prev = P_plus_0;
x_hat_plus_prev = xnom(:,1) + dx_hat_plus_0;

dx_hat_plus = [dx_hat_plus_prev];
P_plus = [P_plus_prev];
x_hat_plus = [x_hat_plus_prev];
sigs = [2.*sqrt(diag(P_plus_prev))];

for k = 1:length(tvec)-1
    t0 = tvec(k); t1 = tvec(k+1);

	[Ftilde_k, Gtilde_k, ~, omegatilde_k] = get_discrete_mats(xnom(:,k), u0, L, delta_T);
    [~, ~, Htilde_k1, ~] = get_discrete_mats(xnom(:,k+1), u0, L, delta_T);

    % prediction
    dx_hat_minus_k1 = Ftilde_k*dx_hat_plus_prev;
    P_minus_k1 = Ftilde_k*P_plus_prev*Ftilde_k' + omegatilde_k*Qkf*omegatilde_k';

    % measurement update
    dy_k1 = yreal(:,k+1) - ynom(:,k+1); dy_k1(1) = wrapToPi(dy_k1(1)); dy_k1(3) = wrapToPi(dy_k1(3));
    S = Htilde_k1*P_minus_k1*Htilde_k1' + Rkf;
    K_k1 = P_minus_k1*Htilde_k1'*inv(S);
    aa=Htilde_k1*dx_hat_minus_k1;
    aa(1) = wrapToPi(aa(1)); aa(3) = wrapToPi(aa(3));
    innov = dy_k1 - aa; innov(1) = wrapToPi(innov(1)); innov(3) = wrapToPi(innov(3));
    dx_hat_plus_k1 = dx_hat_minus_k1 + K_k1*innov;
    tmp = K_k1*Htilde_k1;
    P_plus_k1 = (eye(size(tmp)) - tmp)*P_minus_k1;

    % filtered state
    x_hat_plus_k1 = xnom(:,k+1) + dx_hat_plus_k1;
        
    % bookkeeping
    dx_hat_plus_prev = dx_hat_plus_k1;
    P_plus_prev = P_plus_k1;
    x_hat_plus_prev = x_hat_plus_k1;
    dx_hat_plus = [dx_hat_plus, dx_hat_plus_prev];
    P_plus = [P_plus, P_plus_prev];
    x_hat_plus = [x_hat_plus, x_hat_plus_prev];
    sigs = [sigs, 2.*sqrt(diag(P_plus_prev))];
end

pos_2sig = x_hat_plus + sigs; neg_2sig = x_hat_plus - sigs;

plot_state_errors(tvec, x_hat_plus, pos_2sig, neg_2sig,sigs);

%wrap states etc etc